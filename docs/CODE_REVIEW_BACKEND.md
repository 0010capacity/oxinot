# 백엔드 코드 리뷰 보고서 (Backend Code Review)

## 1. 개요 (Overview)

이 문서는 `oxinot` 프로젝트의 백엔드 코드베이스(Rust/Tauri)에 대한 리뷰 결과를 담고 있습니다. 백엔드는 **Rust**, **Tauri 2.0**, **SQLite (rusqlite)**를 기반으로 하며, 파일 시스템과 로컬 데이터베이스 간의 동기화, 아웃라이너 블록 관리, Git 통합 등을 담당하고 있습니다.

## 2. 아키텍처 및 구조 분석 (Architecture)

### 2.1 디렉토리 구조
`src-tauri/src` 내부는 기능별로 명확하게 모듈화되어 있습니다.
*   **commands/**: 프론트엔드에서 호출하는 Tauri 커맨드 (`block.rs`, `page.rs` 등)
*   **db/**: 데이터베이스 연결 및 스키마 관리 (`connection.rs`)
*   **models/**: 데이터 구조체 정의 (`block.rs` 등)
*   **services/**: 핵심 비즈니스 로직 (`file_sync.rs` 등)

### 2.2 데이터 모델 및 저장소 (Data Model & Storage)
*   **SQLite 중심**: 메타데이터(블록 구조, 순서, 접기 상태 등)는 SQLite에 저장하여 빠른 쿼리와 관계형 데이터 처리를 지원합니다.
*   **Markdown 동기화**: `FileSyncService`와 `sync_page_to_markdown` 유틸리티를 통해 DB의 변경 사항을 로컬 Markdown 파일로 실시간 동기화합니다. 이는 "Local-First" 및 "File-Based" 철학을 잘 따르고 있습니다.
*   **Fractional Indexing**: 블록 순서 관리를 위해 실수형(`f64`) `order_weight`를 사용하고 있습니다. 이는 연결 리스트나 정수형 인덱스보다 재정렬 비용이 저렴한 효율적인 방식입니다.

### 2.3 주요 서비스 로직
*   **Block Commands (`commands/block.rs`)**: 블록의 CRUD 뿐만 아니라 이동(Indent/Outdent), 병합(Merge), 검색(Recursive CTE) 등 복잡한 트리 조작 로직을 포함하고 있습니다. 특히 `merge_blocks`에서의 트랜잭션 처리가 인상적입니다.
*   **File Sync (`services/file_sync.rs`)**: 파일/폴더 생성, 이동, 이름 변경 시 DB와 파일 시스템 간의 정합성을 유지하기 위한 로직이 집중되어 있습니다. 디렉토리 기반 노트(Folder Note) 패턴을 지원하는 점이 특징입니다.

## 3. 코드 품질 상세 (Code Quality)

### 3.1 강점 (Strengths)
1.  **안전성 및 에러 처리**: Rust의 `Result` 타입을 활용하여 파일 시스템 및 DB 작업의 실패 가능성을 명시적으로 처리하고 있습니다. `map_err`를 통해 에러 메시지를 구체화하여 프론트엔드에 전달하는 방식이 일관됩니다.
2.  **트랜잭션 활용**: `merge_blocks` 등 여러 단계의 DB 작업이 필요한 경우 `conn.transaction()`을 사용하여 원자성(Atomicity)을 보장합니다.
3.  **Recursive CTE 활용**: `get_block_ancestors`, `search_blocks` 등에서 SQLite의 재귀 쿼리(WITH RECURSIVE)를 사용하여 트리 구조를 효율적으로 조회합니다. 애플리케이션 레벨에서 재귀 호출을 하는 것보다 성능상 유리합니다.
4.  **테스트 코드**: `commands/block.rs` 하단에 통합 테스트(`test_incremental_insertion` 등)가 포함되어 있어, 실제 DB와 파일 시스템을 사용하는 시나리오를 검증하고 있습니다.

### 3.2 개선이 필요한 부분 (Weaknesses)
1.  **동기화 로직의 복잡성**: `FileSyncService`와 `page_sync` 유틸리티가 분리되어 있으나, 파일 시스템 조작과 DB 업데이트가 양방향으로 일어나는 구조라 버그 발생 가능성이 높습니다. (예: 외부에서 파일 수정 시 DB 역동기화 로직은 이번 리뷰 범위에 포함되지 않았으나, 주의가 필요함)
2.  **SQL 하드코딩**: `rusqlite`를 직접 사용하다 보니 SQL 쿼리가 문자열로 하드코딩되어 있습니다. 복잡한 쿼리(검색, 서브트리 조회)의 경우 가독성이 떨어지고 유지보수가 어려울 수 있습니다. `sqlx`나 가벼운 ORM 도입을 고려해볼 만합니다.
3.  **파일 핸들링 레이스 컨디션**: 파일 시스템 작업(파일 생성/이동)과 DB 작업 사이에 락(Lock)이 명시적으로 보이지 않아, 극단적인 경우 정합성이 깨질 우려가 있습니다. (단, Tauri 커맨드는 기본적으로 비동기 큐에서 처리되므로 완화될 수 있음)

## 4. 개선 제안 (Recommendations)

### 4.1 리팩토링 제안
1.  **쿼리 빌더 도입**: 복잡한 SQL 쿼리(특히 `search_blocks`의 CTE)를 별도의 `.sql` 파일로 분리하거나, `sqlx` 같은 라이브러리를 사용하여 컴파일 타임에 쿼리를 검증하고 가독성을 높이는 것을 추천합니다.
2.  **동기화 매니저 통합**: 파일 시스템 변경과 DB 변경을 조율하는 중앙화된 `ConsistencyManager`를 두어, 모든 변경 사항이 해당 매니저를 통해서만 이루어지도록 강제하면 데이터 불일치를 방지할 수 있습니다.

### 4.2 기능적 제안
1.  **FTS (Full-Text Search) 적용**: 현재 `search_blocks`는 `LIKE %...%` 패턴 매칭을 사용하고 있어 데이터가 많아지면 느려질 수 있습니다. SQLite의 FTS5 모듈을 활성화하여 전문 검색을 도입하면 성능과 정확도를 크게 높일 수 있습니다.
2.  **백업/스냅샷**: 파일 기반이므로 Git이 백업 역할을 일부 수행하지만, DB 파일(`outliner.db`) 자체에 대한 주기적인 백업이나, 마이그레이션 실패 시 자동 복구 메커니즘을 추가하면 안정성이 향상될 것입니다.

## 5. 결론
백엔드 코드는 Rust의 강점을 잘 살려 안정적이고 성능 지향적으로 작성되었습니다. 특히 아웃라이너의 핵심인 트리 구조 데이터 처리에 대한 이해도가 높으며, SQLite의 고급 기능(CTE, Transaction)을 적절히 활용하고 있습니다. 장기적으로는 **SQL 관리의 체계화**와 **동기화 로직의 견고함**을 확보하는 방향으로 발전시키면 더욱 훌륭한 시스템이 될 것입니다.
